<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Crypter - Caesar Cipher</title>
    <link rel="stylesheet" href="style.css">
    <!-- Local jQuery file - remember to download it into your project folder -->
    <script src="jquery-3.7.0.min.js"></script> 
    <style>
        /* Add any specific animations if needed */
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    </style>
</head>
<body class="dark-mode">
<div class="container">
    <div class="top-bar">
        <div class="logo-title">
            <!-- Cipher/Lock Symbol SVG - a new icon for Crypter -->
            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="logo-icon">
                <path d="M12 11V17" stroke="#58a6ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M12 14C10.3431 14 9 12.6569 9 11C9 9.34315 10.3431 8 12 8C13.6569 8 15 9.34315 15 11C15 12.6569 13.6569 14 12 14Z" stroke="#58a6ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2Z" stroke="#58a6ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <h1 id="dashboardTitle">Crypter</h1>
        </div>
        
        <div class="header-controls">
            <!-- Theme Toggle -->
            <div class="toggle-switch">
                <span>Light</span>
                <label class="switch">
                    <input type="checkbox" id="themeToggle" checked>
                    <span class="slider"></span>
                </label>
                <span>Dark</span>
            </div>
            <!-- Info Button for Crypter -->
            <button id="infoBtn" class="btn-header">â“˜ Info</button>
        </div>
    </div>

    <div class="main-content-area">
        <div class="cipher-selection-section card">
            <h2>Select Cipher:</h2>
            <div class="cipher-buttons">
                <button id="caesarCipherBtn" class="btn-main btn-blue active-cipher" data-cipher="caesar">Caesar Cipher</button>
                <button id="railFenceCipherBtn" class="btn-main btn-blue" data-cipher="railfence">Rail Fence Cipher</button>
                <button id="playfairCipherBtn" class="btn-main btn-blue" data-cipher="playfair">Playfair Cipher</button>
            </div>
        </div>

        <!-- Unified Cipher Tool Section -->
        <div id="unifiedCipherToolSection" class="cipher-tool-section card">
            <h2 id="currentCipherTitle">Caesar Cipher</h2>
            <div class="input-output-group">
                <div class="input-section">
                    <label for="inputText">Input Text:</label>
                    <textarea id="inputText" placeholder="Enter text to encrypt or decrypt..."></textarea>
                </div>
                <div class="output-section">
                    <label for="outputText">Output Text:</label>
                    <textarea id="outputText" placeholder="Result will appear here..." readonly></textarea>
                </div>
            </div>

            <div class="controls-group">
                <!-- Cipher-specific controls will be dynamically loaded here -->
                <div id="caesarControls" class="cipher-controls active-controls">
                    <div class="shift-input-group">
                        <label for="shiftKey">Shift Key (1-25):</label>
                        <input type="number" id="shiftKey" value="3" min="1" max="25">
                    </div>
                </div>
                <div id="railFenceControls" class="cipher-controls hidden-controls">
                    <div class="shift-input-group">
                        <label for="railFenceKey">Key (Number of Rails):</label>
                        <input type="number" id="railFenceKey" value="3" min="2">
                    </div>
                </div>
                <div id="playfairControls" class="cipher-controls hidden-controls">
                    <div class="shift-input-group">
                        <label for="playfairKeyword">Keyword:</label>
                        <input type="text" id="playfairKeyword" value="MONARCHY">
                    </div>
                </div>

                <div class="action-buttons">
                    <button id="encryptBtn" class="btn-main btn-green">Encrypt</button>
                    <button id="decryptBtn" class="btn-main btn-red">Decrypt</button>
                </div>
            </div>
        </div>

    </div>
</div>

<!-- Info Modal for Crypter -->
<div id="infoModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>About Crypter</h2>
            <span class="close-button info-close-button">&times;</span>
        </div>
        <div class="modal-body">
            <p>Welcome to Crypter! This tool allows you to encrypt and decrypt text using various classical ciphers.</p>
            <p>Currently available ciphers:</p>
            <ul>
                <li>**Caesar Cipher:** A simple substitution cipher where each letter is shifted a fixed number of positions down the alphabet.</li>
                <li>**Rail Fence Cipher:** A transposition cipher that writes plaintext downwards and diagonally on successive "rails" of an imaginary fence.</li>
                <li>**Playfair Cipher:** A manual symmetric encryption technique that encrypts pairs of letters (digraphs) instead of single letters.</li>
            </ul>
        </div>
    </div>
</div>

<!-- Custom Alert Modal (from previous project) -->
<div id="customAlertModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="customAlertTitle">Message</h2>
            <span class="close-button custom-alert-close-button">&times;</span>
        </div>
        <div class="modal-body">
            <p id="customAlertMessage"></p>
            <div style="text-align: right; margin-top: 20px;">
                <button class="btn-main btn-green custom-alert-ok-button">OK</button>
            </div>
        </div>
    </div>
</div>

<script>
    // Custom Alert/Message Box Logic
    const customAlertModal = $('#customAlertModal');
    const customAlertTitle = $('#customAlertTitle');
    const customAlertMessage = $('#customAlertMessage');

    const showAlert = (title, message) => {
        customAlertTitle.text(title);
        customAlertMessage.text(message);
        customAlertModal.show();
    };

    $('.custom-alert-close-button, .custom-alert-ok-button').on('click', () => customAlertModal.hide());
    $(window).on('click', (event) => {
        if ($(event.target).is(customAlertModal)) {
            customAlertModal.hide();
        }
    });

    $(document).ready(function () {
        // --- Theme Toggle Logic (reused) ---
        const applyTheme = (theme) => {
            $('body').removeClass('dark-mode light-mode').addClass(theme);
            localStorage.setItem('theme', theme);
        };

        $('#themeToggle').on('change', function() {
            if ($(this).is(':checked')) {
                applyTheme('dark-mode');
            } else {
                applyTheme('light-mode');
            }
        });

        // Set initial theme based on localStorage or default to dark
        if (localStorage.getItem('theme') === 'light-mode') {
            $('#themeToggle').prop('checked', false);
            applyTheme('light-mode');
        } else {
            $('#themeToggle').prop('checked', true);
            applyTheme('dark-mode');
        }

        // --- Modals Logic (reused) ---
        const infoModal = $('#infoModal');
        $('#infoBtn').on('click', () => infoModal.show());
        $('.info-close-button').on('click', () => infoModal.hide());
        $(window).on('click', (event) => {
            if ($(event.target).is(infoModal)) {
                infoModal.hide();
            }
        });

        // --- Cipher Switching Logic ---
        let activeCipher = 'caesar'; // Default active cipher

        const showCipherTool = (cipherName) => {
            // Update active cipher button
            $('.cipher-buttons .btn-main').removeClass('active-cipher');
            $(`button[data-cipher="${cipherName}"]`).addClass('active-cipher');
            
            // Update current cipher title
            $('#currentCipherTitle').text(`${cipherName.charAt(0).toUpperCase() + cipherName.slice(1)} Cipher`);

            // Hide all cipher-specific controls and show only the active one
            $('.cipher-controls').removeClass('active-controls').addClass('hidden-controls');
            $(`#${cipherName}Controls`).removeClass('hidden-controls').addClass('active-controls');

            activeCipher = cipherName;
            // Clear textareas when switching ciphers
            $('#inputText').val('');
            $('#outputText').val('');
        };

        // Attach click handlers to cipher selection buttons
        $('#caesarCipherBtn').on('click', () => showCipherTool('caesar'));
        $('#railFenceCipherBtn').on('click', () => showCipherTool('railfence'));
        $('#playfairCipherBtn').on('click', () => showCipherTool('playfair'));

        // --- Cipher Implementations ---

        // Caesar Cipher
        const caesarCipher = (text, shift, encrypt = true) => {
            let result = '';
            shift = shift % 26; 
            if (!encrypt) {
                shift = (26 - shift) % 26; 
            }

            for (let i = 0; i < text.length; i++) {
                let char = text.charCodeAt(i);

                if (char >= 65 && char <= 90) { // Uppercase letters (A-Z)
                    result += String.fromCharCode(((char - 65 + shift) % 26) + 65);
                } else if (char >= 97 && char <= 122) { // Lowercase letters (a-z)
                    result += String.fromCharCode(((char - 97 + shift) % 26) + 97);
                } else {
                    result += text.charAt(i); // Keep non-alphabetic characters as is
                }
            }
            return result;
        };

        // Rail Fence Cipher
        const railFenceCipher = (text, key, encrypt = true) => {
            text = text.replace(/[^A-Za-z]/g, '').toUpperCase(); // Only letters, uppercase
            if (key <= 1 || text.length === 0) return text;

            let rail = [];
            for(let i = 0; i < key; i++) {
                rail.push([]);
            }

            let dirDown = false;
            let row = 0;

            for(let i = 0; i < text.length; i++) {
                if (row === 0 || row === key - 1) {
                    dirDown = !dirDown;
                }
                rail[row].push(text.charAt(i));
                dirDown ? row++ : row--;
            }

            if (encrypt) {
                let result = [];
                for(let i = 0; i < key; i++) {
                    result.push(...rail[i]);
                }
                return result.join('');
            } else { // Decrypt
                let result = [];
                let ptr = 0;
                for(let i = 0; i < key; i++) {
                    for(let j = 0; j < rail[i].length; j++) {
                        rail[i][j] = text.charAt(ptr++);
                    }
                }

                dirDown = false;
                row = 0;
                for(let i = 0; i < text.length; i++) {
                    if (row === 0 || row === key - 1) {
                        dirDown = !dirDown;
                    }
                    result.push(rail[row].shift());
                    dirDown ? row++ : row--;
                }
                return result.join('');
            }
        };

        // Playfair Cipher
        const playfairCipher = (text, keyword, encrypt = true) => {
            // Helper to generate the 5x5 key matrix
            const generateKeyMatrix = (key) => {
                const alphabet = "ABCDEFGHIKLMNOPQRSTUVWXYZ"; // I/J are combined
                let processedKey = "";
                // Remove duplicates and 'J', add remaining alphabet
                for (let char of key.toUpperCase()) {
                    if (char !== 'J' && !processedKey.includes(char)) {
                        processedKey += char;
                    }
                }
                for (let char of alphabet) {
                    if (!processedKey.includes(char)) {
                        processedKey += char;
                    }
                }

                let matrix = [];
                for (let i = 0; i < 5; i++) {
                    matrix.push(processedKey.substring(i * 5, (i * 5) + 5).split(''));
                }
                return matrix;
            };

            // Helper to find character position in matrix
            const findCharPos = (matrix, char) => {
                for (let r = 0; r < 5; r++) {
                    for (let c = 0; c < 5; c++) {
                        if (matrix[r][c] === char) {
                            return { r, c };
                        }
                    }
                }
                return null; // Should not happen with valid input
            };

            // Prepare plaintext
            let preparedText = text.toUpperCase().replace(/[^A-Z]/g, '');
            preparedText = preparedText.replace(/J/g, 'I'); // Replace J with I

            let digraphs = [];
            for (let i = 0; i < preparedText.length; i += 2) {
                let char1 = preparedText[i];
                let char2 = preparedText[i + 1];

                if (char2 === undefined) { // Last character, add X
                    digraphs.push([char1, 'X']);
                } else if (char1 === char2) { // Double letters, insert X
                    digraphs.push([char1, 'X']);
                    i--; // Re-process the second original character
                } else {
                    digraphs.push([char1, char2]);
                }
            }

            const keyMatrix = generateKeyMatrix(keyword);
            let result = [];

            for (let digraph of digraphs) {
                let pos1 = findCharPos(keyMatrix, digraph[0]);
                let pos2 = findCharPos(keyMatrix, digraph[1]);

                let newChar1, newChar2;

                if (pos1.r === pos2.r) { // Same row
                    if (encrypt) {
                        newChar1 = keyMatrix[pos1.r][(pos1.c + 1) % 5];
                        newChar2 = keyMatrix[pos2.r][(pos2.c + 1) % 5];
                    } else { // Decrypt
                        newChar1 = keyMatrix[pos1.r][(pos1.c - 1 + 5) % 5];
                        newChar2 = keyMatrix[pos2.r][(pos2.c - 1 + 5) % 5];
                    }
                } else if (pos1.c === pos2.c) { // Same column
                    if (encrypt) {
                        newChar1 = keyMatrix[(pos1.r + 1) % 5][pos1.c];
                        newChar2 = keyMatrix[(pos2.r + 1) % 5][pos2.c];
                    } else { // Decrypt
                        newChar1 = keyMatrix[(pos1.r - 1 + 5) % 5][pos1.c];
                        newChar2 = keyMatrix[(pos2.r - 1 + 5) % 5][pos2.c];
                    }
                } else { // Forms a rectangle
                    newChar1 = keyMatrix[pos1.r][pos2.c];
                    newChar2 = keyMatrix[pos2.r][pos1.c];
                }
                result.push(newChar1, newChar2);
            }
            return result.join('');
        };

        // --- Unified Encryption/Decryption Handler ---
        $('#encryptBtn').on('click', function() {
            const inputText = $('#inputText').val();
            let outputText = '';

            if (inputText.trim() === '') {
                showAlert('Input Missing', 'Please enter text to encrypt.');
                return;
            }

            switch(activeCipher) {
                case 'caesar':
                    const caesarShiftKey = parseInt($('#shiftKey').val());
                    if (isNaN(caesarShiftKey) || caesarShiftKey < 1 || caesarShiftKey > 25) {
                        showAlert('Invalid Shift Key', 'Please enter a valid shift key between 1 and 25.');
                        return;
                    }
                    outputText = caesarCipher(inputText, caesarShiftKey, true);
                    break;
                case 'railfence':
                    const railFenceKey = parseInt($('#railFenceKey').val());
                    if (isNaN(railFenceKey) || railFenceKey < 2) {
                        showAlert('Invalid Key', 'Please enter a valid key (number of rails, minimum 2).');
                        return;
                    }
                    outputText = railFenceCipher(inputText, railFenceKey, true);
                    break;
                case 'playfair':
                    const playfairKeyword = $('#playfairKeyword').val().toUpperCase().replace(/[^A-Z]/g, '');
                    if (playfairKeyword.length === 0) {
                        showAlert('Invalid Keyword', 'Please enter a valid keyword for Playfair cipher.');
                        return;
                    }
                    outputText = playfairCipher(inputText, playfairKeyword, true);
                    break;
                default:
                    showAlert('Error', 'Unknown cipher selected.');
                    return;
            }
            $('#outputText').val(outputText);
        });

        $('#decryptBtn').on('click', function() {
            const inputText = $('#inputText').val();
            let outputText = '';

            if (inputText.trim() === '') {
                showAlert('Input Missing', 'Please enter text to decrypt.');
                return;
            }

            switch(activeCipher) {
                case 'caesar':
                    const caesarShiftKey = parseInt($('#shiftKey').val());
                    if (isNaN(caesarShiftKey) || caesarShiftKey < 1 || caesarShiftKey > 25) {
                        showAlert('Invalid Shift Key', 'Please enter a valid shift key between 1 and 25.');
                        return;
                    }
                    outputText = caesarCipher(inputText, caesarShiftKey, false);
                    break;
                case 'railfence':
                    const railFenceKey = parseInt($('#railFenceKey').val());
                    if (isNaN(railFenceKey) || railFenceKey < 2) {
                        showAlert('Invalid Key', 'Please enter a valid key (number of rails, minimum 2).');
                        return;
                    }
                    outputText = railFenceCipher(inputText, railFenceKey, false);
                    break;
                case 'playfair':
                    const playfairKeyword = $('#playfairKeyword').val().toUpperCase().replace(/[^A-Z]/g, '');
                    if (playfairKeyword.length === 0) {
                        showAlert('Invalid Keyword', 'Please enter a valid keyword for Playfair cipher.');
                        return;
                    }
                    outputText = playfairCipher(inputText, playfairKeyword, false);
                    break;
                default:
                    showAlert('Error', 'Unknown cipher selected.');
                    return;
            }
            $('#outputText').val(outputText);
        });

        // Initial setup: show Caesar cipher section
        showCipherTool('caesar');
    });
</script>
</body>
</html>
