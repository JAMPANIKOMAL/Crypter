<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Crypter - Caesar Cipher</title>
    <link rel="stylesheet" href="style.css">
    <!-- Using a CDN for jQuery for better compatibility -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script> 
</head>
<body class="dark-mode">
<div class="container">
    <div class="top-bar">
        <div class="logo-title">
            <!-- Cipher/Lock Symbol SVG - a new icon for Crypter -->
            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="logo-icon">
                <path d="M12 11V17" stroke="#58a6ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M12 14C10.3431 14 9 12.6569 9 11C9 9.34315 10.3431 8 12 8C13.6569 8 15 9.34315 15 11C15 12.6569 13.6569 14 12 14Z" stroke="#58a6ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2Z" stroke="#58a6ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <h1 id="dashboardTitle">Crypter</h1>
        </div>
        
        <div class="header-controls">
            <!-- Theme Toggle -->
            <div class="toggle-switch">
                <span>Light</span>
                <label class="switch">
                    <input type="checkbox" id="themeToggle" checked>
                    <span class="slider"></span>
                </label>
                <span>Dark</span>
            </div>
            <!-- Info Button for Crypter -->
            <button id="infoBtn" class="btn-header">â“˜ Info</button>
        </div>
    </div>

    <div class="main-content-area">
        <div class="cipher-selection-section card">
            <h2>Select Cipher:</h2>
            <div class="cipher-buttons">
                <button id="caesarCipherBtn" class="btn-main btn-blue active-cipher" data-cipher="caesar">Caesar Cipher</button>
                <button id="railFenceCipherBtn" class="btn-main btn-blue" data-cipher="railfence">Rail Fence Cipher</button>
                <button id="playfairCipherBtn" class="btn-main btn-blue" data-cipher="playfair">Playfair Cipher</button>
            </div>
        </div>

        <!-- Unified Cipher Tool Section -->
        <div id="unifiedCipherToolSection" class="cipher-tool-section card">
            <h2 id="currentCipherTitle">Caesar Cipher</h2>
            <div class="input-output-group">
                <div class="input-section">
                    <label for="inputText">Input Text:</label>
                    <textarea id="inputText" placeholder="Enter text to encrypt or decrypt..."></textarea>
                </div>
                <div class="output-section">
                    <label for="outputText">Output Text:</label>
                    <textarea id="outputText" placeholder="Result will appear here..." readonly></textarea>
                </div>
            </div>

            <div class="controls-group">
                <!-- Cipher-specific controls are now correctly toggled -->
                <div id="caesarControls" class="cipher-controls active-controls">
                    <div class="shift-input-group">
                        <label for="shiftKey">Shift Key (1-25):</label>
                        <input type="number" id="shiftKey" value="3" min="1" max="25">
                    </div>
                </div>
                <div id="railfenceControls" class="cipher-controls hidden-controls">
                    <div class="shift-input-group">
                        <label for="railFenceKey">Key (Number of Rails):</label>
                        <input type="number" id="railFenceKey" value="3" min="2">
                    </div>
                </div>
                <div id="playfairControls" class="cipher-controls hidden-controls">
                    <div class="shift-input-group">
                        <label for="playfairKeyword">Keyword:</label>
                        <input type="text" id="playfairKeyword" value="MONARCHY">
                    </div>
                </div>

                <div class="action-buttons">
                    <button id="encryptBtn" class="btn-main btn-green">Encrypt</button>
                    <button id="decryptBtn" class="btn-main btn-red">Decrypt</button>
                </div>
            </div>
        </div>

    </div>
</div>

<!-- Info Modal for Crypter -->
<div id="infoModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>About Crypter</h2>
            <span class="close-button info-close-button">&times;</span>
        </div>
        <div class="modal-body">
            <p>Welcome to Crypter! This tool allows you to encrypt and decrypt text using various classical ciphers.</p>
            <p>Currently available ciphers:</p>
            <ul>
                <li><strong>Caesar Cipher:</strong> A simple substitution cipher where each letter is shifted a fixed number of positions down the alphabet.</li>
                <li><strong>Rail Fence Cipher:</strong> A transposition cipher that writes plaintext downwards and diagonally on successive "rails" of an imaginary fence.</li>
                <li><strong>Playfair Cipher:</strong> A manual symmetric encryption technique that encrypts pairs of letters (digraphs) instead of single letters.</li>
            </ul>
        </div>
    </div>
</div>

<!-- Custom Alert Modal -->
<div id="customAlertModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="customAlertTitle">Message</h2>
            <span class="close-button custom-alert-close-button">&times;</span>
        </div>
        <div class="modal-body">
            <p id="customAlertMessage"></p>
            <div style="text-align: right; margin-top: 20px;">
                <button class="btn-main btn-green custom-alert-ok-button">OK</button>
            </div>
        </div>
    </div>
</div>

<script>
    $(document).ready(function () {
        // --- Custom Alert/Message Box Logic ---
        const customAlertModal = $('#customAlertModal');
        const customAlertTitle = $('#customAlertTitle');
        const customAlertMessage = $('#customAlertMessage');

        const showAlert = (title, message) => {
            customAlertTitle.text(title);
            customAlertMessage.text(message);
            customAlertModal.show();
        };

        $('.custom-alert-close-button, .custom-alert-ok-button').on('click', () => customAlertModal.hide());
        $(window).on('click', (event) => {
            if ($(event.target).is(customAlertModal)) {
                customAlertModal.hide();
            }
        });

        // --- Theme Toggle Logic ---
        const applyTheme = (theme) => {
            $('body').removeClass('dark-mode light-mode').addClass(theme);
            localStorage.setItem('theme', theme);
        };

        $('#themeToggle').on('change', function() {
            if ($(this).is(':checked')) {
                applyTheme('dark-mode');
            } else {
                applyTheme('light-mode');
            }
        });

        if (localStorage.getItem('theme') === 'light-mode') {
            $('#themeToggle').prop('checked', false);
            applyTheme('light-mode');
        } else {
            $('#themeToggle').prop('checked', true);
            applyTheme('dark-mode');
        }

        // --- Modals Logic ---
        const infoModal = $('#infoModal');
        $('#infoBtn').on('click', () => infoModal.show());
        $('.info-close-button').on('click', () => infoModal.hide());
        $(window).on('click', (event) => {
            if ($(event.target).is(infoModal)) {
                infoModal.hide();
            }
        });

        // --- Cipher Switching Logic ---
        let activeCipher = 'caesar'; 

        const showCipherTool = (cipherName) => {
            $('.cipher-buttons .btn-main').removeClass('active-cipher');
            $(`button[data-cipher="${cipherName}"]`).addClass('active-cipher');
            
            // Capitalize first letter for the title
            const title = cipherName.charAt(0).toUpperCase() + cipherName.slice(1) + " Cipher";
            $('#currentCipherTitle').text(title);

            $('.cipher-controls').removeClass('active-controls').addClass('hidden-controls');
            // This selector now correctly finds the controls for each cipher
            $(`#${cipherName}Controls`).removeClass('hidden-controls').addClass('active-controls');

            activeCipher = cipherName;
            $('#inputText').val('');
            $('#outputText').val('');
        };

        $('#caesarCipherBtn').on('click', () => showCipherTool('caesar'));
        $('#railFenceCipherBtn').on('click', () => showCipherTool('railfence'));
        $('#playfairCipherBtn').on('click', () => showCipherTool('playfair'));

        // --- Cipher Implementations ---

        // Caesar Cipher
        const caesarCipher = (text, shift, encrypt = true) => {
            let result = '';
            shift = shift % 26; 
            if (!encrypt) {
                shift = (26 - shift) % 26; 
            }

            for (let i = 0; i < text.length; i++) {
                let charCode = text.charCodeAt(i);

                if (charCode >= 65 && charCode <= 90) { // Uppercase letters (A-Z)
                    result += String.fromCharCode(((charCode - 65 + shift) % 26) + 65);
                } else if (charCode >= 97 && charCode <= 122) { // Lowercase letters (a-z)
                    result += String.fromCharCode(((charCode - 97 + shift) % 26) + 97);
                } else {
                    result += text.charAt(i); // Keep non-alphabetic characters as is
                }
            }
            return result;
        };

        // Rail Fence Cipher (Encrypt)
        const railFenceEncrypt = (text, key) => {
            if (key <= 1) return text;

            const rails = Array.from({ length: key }, () => []);
            let rail = 0;
            let direction = 1;

            for (const char of text) {
                rails[rail].push(char);
                rail += direction;
                if (rail === 0 || rail === key - 1) {
                    direction *= -1;
                }
            }
            return rails.map(rail => rail.join('')).join('');
        };

        // Rail Fence Cipher (Decrypt)
        const railFenceDecrypt = (cipher, key) => {
            if (key <= 1) return cipher;

            const railLengths = Array(key).fill(0);
            let rail = 0;
            let direction = 1;

            for (let i = 0; i < cipher.length; i++) {
                railLengths[rail]++;
                rail += direction;
                if (rail === 0 || rail === key - 1) {
                    direction *= -1;
                }
            }

            const rails = [];
            let cipherIndex = 0;
            for (const len of railLengths) {
                rails.push(cipher.substring(cipherIndex, cipherIndex + len).split(''));
                cipherIndex += len;
            }

            let result = '';
            rail = 0;
            direction = 1;
            for (let i = 0; i < cipher.length; i++) {
                result += rails[rail].shift();
                rail += direction;
                if (rail === 0 || rail === key - 1) {
                    direction *= -1;
                }
            }
            return result;
        };


        // Playfair Cipher
        const playfairCipher = (text, keyword, encrypt = true) => {
            const generateKeyMatrix = (key) => {
                const alphabet = "ABCDEFGHIKLMNOPQRSTUVWXYZ"; // I/J are combined
                let processedKey = "";
                for (let char of key.toUpperCase()) {
                    if (char !== 'J' && !processedKey.includes(char)) {
                        processedKey += char;
                    }
                }
                for (let char of alphabet) {
                    if (!processedKey.includes(char)) {
                        processedKey += char;
                    }
                }

                let matrix = [];
                for (let i = 0; i < 5; i++) {
                    matrix.push(processedKey.substring(i * 5, (i * 5) + 5).split(''));
                }
                return matrix;
            };

            const findCharPos = (matrix, char) => {
                for (let r = 0; r < 5; r++) {
                    for (let c = 0; c < 5; c++) {
                        if (matrix[r][c] === char) {
                            return { r, c };
                        }
                    }
                }
                return null;
            };

            let preparedText = text.toUpperCase().replace(/[^A-Z]/g, '').replace(/J/g, 'I');
            
            let digraphs = [];
            let i = 0;
            while (i < preparedText.length) {
                let char1 = preparedText[i];
                let char2 = preparedText[i + 1];

                if (char2 === undefined) {
                    digraphs.push([char1, 'X']);
                    i += 1;
                } else if (char1 === char2) {
                    digraphs.push([char1, 'X']);
                    i += 1;
                } else {
                    digraphs.push([char1, char2]);
                    i += 2;
                }
            }

            const keyMatrix = generateKeyMatrix(keyword);
            let result = [];
            const direction = encrypt ? 1 : -1;

            for (let digraph of digraphs) {
                let pos1 = findCharPos(keyMatrix, digraph[0]);
                let pos2 = findCharPos(keyMatrix, digraph[1]);
                let newChar1, newChar2;

                if (pos1.r === pos2.r) { // Same row
                    newChar1 = keyMatrix[pos1.r][(pos1.c + direction + 5) % 5];
                    newChar2 = keyMatrix[pos2.r][(pos2.c + direction + 5) % 5];
                } else if (pos1.c === pos2.c) { // Same column
                    newChar1 = keyMatrix[(pos1.r + direction + 5) % 5][pos1.c];
                    newChar2 = keyMatrix[(pos2.r + direction + 5) % 5][pos2.c];
                } else { // Forms a rectangle
                    newChar1 = keyMatrix[pos1.r][pos2.c];
                    newChar2 = keyMatrix[pos2.r][pos1.c];
                }
                result.push(newChar1, newChar2);
            }
            return result.join('');
        };

        // --- Unified Encryption/Decryption Handler ---
        const handleCipherAction = (isEncrypt) => {
            const inputText = $('#inputText').val();
            let outputText = '';

            if (inputText.trim() === '') {
                showAlert('Input Missing', `Please enter text to ${isEncrypt ? 'encrypt' : 'decrypt'}.`);
                return;
            }

            switch(activeCipher) {
                case 'caesar':
                    const caesarShiftKey = parseInt($('#shiftKey').val());
                    if (isNaN(caesarShiftKey) || caesarShiftKey < 1 || caesarShiftKey > 25) {
                        showAlert('Invalid Shift Key', 'Please enter a valid shift key between 1 and 25.');
                        return;
                    }
                    outputText = caesarCipher(inputText, caesarShiftKey, isEncrypt);
                    break;
                case 'railfence':
                    const railFenceKey = parseInt($('#railFenceKey').val());
                    if (isNaN(railFenceKey) || railFenceKey < 2) {
                        showAlert('Invalid Key', 'Please enter a valid key (number of rails, minimum 2).');
                        return;
                    }
                    outputText = isEncrypt ? railFenceEncrypt(inputText, railFenceKey) : railFenceDecrypt(inputText, railFenceKey);
                    break;
                case 'playfair':
                    const playfairKeyword = $('#playfairKeyword').val().toUpperCase().replace(/[^A-Z]/g, '');
                    if (playfairKeyword.length === 0) {
                        showAlert('Invalid Keyword', 'Please enter a valid keyword for Playfair cipher.');
                        return;
                    }
                    outputText = playfairCipher(inputText, playfairKeyword, isEncrypt);
                    break;
                default:
                    showAlert('Error', 'Unknown cipher selected.');
                    return;
            }
            $('#outputText').val(outputText);
        };

        $('#encryptBtn').on('click', () => handleCipherAction(true));
        $('#decryptBtn').on('click', () => handleCipherAction(false));

        // Initial setup: show Caesar cipher section
        showCipherTool('caesar');
    });
</script>
</body>
</html>
